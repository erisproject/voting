\documentclass[12pt]{article}
\usepackage{xltxtra}
\usepackage{xunicode}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage[left=2.54cm,top=2.54cm,right=2.54cm,bottom=2.54cm,nohead]{geometry}
\usepackage{enumerate}
\usepackage{multirow}
\usepackage{array}
\usepackage{graphicx}
\usepackage{url}
\usepackage[
    backend=biber,
    natbib=true,
    style=authoryear-comp,
    alldates=long,
    dateabbrev=false,
    datezeros=false
]{biblatex}
\addbibresource{refs.bib}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}

\numberwithin{equation}{subsection}

\bibliography{refs}

\title{Voting simulation: an Eris application}
\date{September 2013}
\author{Jason Rhinelander}

\begin{document}

\maketitle
\thispagestyle{empty}

%\null\vfill
%\begin{center}
%    \copyright 2012 Jason Rhinelander
%\end{center}
%\newpage

% Things I forget:
% A \prec B -- A < B, but with curly <
% A \succ B -- A > B, with curly >
% \precsim, \succsim: same as above, but with ~ below.
% \mathbb{R} -- double-struck R, i.e. rational numbers
% \varnothing -- circle with a line through it, i.e. empty set; also available \emptyset, which uses 0 instead of circle
% \subset, \subseteq, \subsetneq: subset (ambiguous), subset, strict subset
% \superset, ...: same, for supersets
% \dots: ellipsis (...)
% \neg, \AND, \OR: logic symbols for not, and, or
% \iff (alias for \Longleftrightarrow): two-way implication (i.e. two lines in arrow base)
% \Longrightarrow: one-way implication (i.e. two lines in arrow base)
% \cap and \cup for set intersection and union

\section{Introduction}\label{s:intro}

This paper proposes both a modelling technique and preliminary results of an application of that
technique to analyse voting outcomes using richer models than is feasible in the traditional purely
mathematical, equilibrium-based technique.  It accomplishes this through use of the ``Eris''
library, a software library designed by the author for analysing agent-based economic computational
modelling.  The model consists of Downsian-style voters and parties in a one-dimensional issue
space, but several complexities not typically solvable in a mathematical framework: voter movement
through a separate network of friends, and multiple parties with movement constraints.

There are thus three main purposes to this paper: first, as a demonstration and practical
application of the Eris software library; second, as a exploration of how a three-party,
one-dimensional voting system can still be modelled; and finally as a demonstration of the
usefulness of agent-based modelling as a technique for exploring economics models.

\section{Literature}\label{s:lit}

Agent-based modelling (ABM) and, specifically, its application to economics problems---sometimes
referred to as Agent-based Computational Economics (ACE)---is a technique based on the principal of
emergent behaviour from the complex interaction of relatively simple rules.

One of the earliest works in this technique was the ``Game of Life'', created by mathematician John
Conway in 1970.  Conway's structure consisted of grid points in a two-dimensional space where each
point can be ``alive'' or ``dead'' with simple rules about the number of living neighbours
determining the state of each grid point in the next period\footnote{Specifically, a point continues
living it has 2 or 3 neighbours, comes to life if it has exactly three neighbours, and dies (or
stays dead) otherwise.}.  From these relatively simple rules emerged great complexity over decades
of research; in 2000, Paul Rendell released a Turing machine\footnote{Simply put, a Turing machine
is a system that is theoretically capable of performing any arbitrary computational algorithm}
implemented using only Conway's rules.

In the discipline of economics, the use of computational modelling has gained some traction since
the mid 1990s.  \citet{hce:Tesf} provides an excellent overview of the philosophy and strengths and
weaknesses of ACE.  As she points out, ACE involves specifying less abstract individual behavioural
models than equation-based modelling; the modelling emphasis is on structure rather than equilibrium,
which allows freedoms in modelling that are limited by the assumptions required for ensuring
equilibria in traditional models.  Shes argues that the place for ACE is as a complement, rather
than substitute for mathematical modelling: in this purpose ACE allow us to examine not just the
equilibria of a model, but how---and perhaps more importantly \emph{whether}---equilibria are
attainable.  \citeauthor{hce:Tesf} suggests and warns that programming---which she sees as an
underused but ``beautiful'' branch of mathematics---is insufficiently instructed to economics
graduate students, despite what she sees as the great power of this mathematical approach to
answering the problems of economics.  She concludes aptly that ``programming frees us to adapt the tool to
the problem rather than the problem to the tool,'' recommending an increasing role for teaching
programming skills at the graduate level.

\citet{hce:Judd}, well known for his often-forceful advancement of computational techniques for
economics problems, argues similarly, attempting to address many of the common criticisms of
computational techniques.  \citeauthor{hce:Judd} reinterprets \citet{Tukey62} who, on the topic of
statistical analysis, wrote that ``[t]he most important maxim for data analysis to heed, and one
which many statisticians seem to have shunned, is this: `Far better an approximate answer to the
\emph{right} question, which is often vague, than an \emph{exact} answer to the wrong question,
which can always be made precise.' ''  Judd argues that \citeauthor{Tukey62}'s maxim applies equally
well to economists and computational modelling as it did to statisticians and statistical analysis:
that computational modelling allows analysis of questions that standard models simply cannot
address; rather than shunning such questions economists should embrace computational techniques as a
way to enlarge the set of questions economics can answer.

On the more specific topic of voting models, the literature dates back to at least \citet{Hotel29}'s
model of single-dimensional spatial competition, which formed the basic foundation of
\citet{Downs57}'s seminal work showing that two-candidate models converge to both candidates
locating at the median voter's position.  \citeauthor{Downs57} goes further, however, in examining
various conditions in which parties do not converge to the median, such as imperfect information of
political parties or voters, shifting tastes of voters, left open the possibility and explored some
richer models using the one-dimensional space by clarifying the various assumptions required.
\citeauthor{Downs57} explores some of these possibilities, concluding that voting models without
strong restrictions can open up many other electoral outcomes other than parties locating at the
median voter.

One of the early works applying ACE to voting models is \citet{KMP92}, which found that parties in
multidimensional issue spaces tend to coalesce to the central regions of the issue space.  The basic
KMP model used in \citet{KMP92} and many later works postulates parties (or candidates) choosing
locations in an $N$-dimensional space, and, unlike in more traditional spatial location models,
imposes constraints on the information they have available while restricting the movements they may
make to a neighbourhood of their current position.  \citet{KMP92}, and most papers following it, use
periodic polling as the only source of the parties' information.  \citet{KMP98} followed up the
earlier paper by looking more closely at the relationship between voter preferences and policy
convergence.  \citet{Plumper08} uses a computational technique involving parties having unlimited
polling ability and an ability to move to any location, but with voter ``memory'' changing the
parties' effective locations to a weighted mean of current and previous positions.  The authors
results show a failure of parties to converge to voter means in multi-party competition in
two-dimensional policy space, but rather to obtain a sort of orbit around, but not at, the
two-dimensional mean.\footnote{
    Earlier work by this author in reproducing the work of \citet{Plumper08} has lead to some doubt
    of the strength of the results of the paper: the few presented ``example'' outcomes in the
    model, upon which much of the paper's conclusions are drawn, appear to be hand-picked examples
    of interesting results rather than typical cases.  Though the paper also included statistical
    analysis concluding that a larger number of parties increased party positioning volatility, that
    analysis was also of questionable quality with likely severe biases because of the construction
    of the data sets used for the analaysis.  More information is available in this author's report
    on reimplementing \citet{Plumper08}, available at
\url{https://imaginary.ca/papers/2013/pm08/report.pdf}.}
\citet{Jackson03} looks at a computational single-dimension, two-party election in which parties
adapt to voters, as in KMP, but voters also adapt their preferences to those of the parties.  An
overview of some of these and other computational approaches to addressing political issues is to be
found in \citet{Handbook29}.

\section{Model}\label{s:model}

The model proposed by this paper consists of a Hotelling or Downsian style 1-dimensional voting
space with boundaries at -1 and 1, with negative values considered ``left'' and positive values
considered ``right''.\footnote{The end-points are arbitrary in a
    mathematical sense, but in a computational sense matter: floating point values are stored with
    the same \emph{relative} precision, which means values close to 0 have significantly more
    \emph{absolute} precision than those close to 1.  Making the interval symmetric around 0
    ensures that there is no possible left/right bias coming from numerical imprecision.  Other
    potential ranges (not examined by this paper) are $\hdots, [0.5, 1], [1,2], [2,4], [4,8],
    \hdots$, or subsets thereof, each of which has all values of identical numerical precision.
}  There are a ``large number''---chosen to be 999---distributed in different methods (discussed
below), and a small number (2 or 3) of parties.  There is also an asymmetric network of voter
friendships that is used to allow voters to influence each other.  Parties get information in each
stage from poll results and use this information to take a step right or left.

Voters in this model have two effects.  First, and most obvious, voters vote for parties and can
observe the party positions.  This paper currently assumes voters are sincere: that is, they vote
for the nearest party.  The second effect of voters is that there is an underlying asymmetric
network of friendships between voters, which is assumed independent of political position.
Asymmetric in this context means that friendships are one-way, i.e.\ $v_A$ can have $v_B$ as a
friend even if $v_B$ does not have $v_A$ as a friend.  This asymmetry could be easily resolved (i.e.\ $v_A$
is a friend of $v_B$ if and only if $v_B$ is a friend of $v_A$), but it is not clear that this would
qualitatively change the result.

The role of friendships in the model is to (temporarily) influence the political position of
friends.  Conceptually, this is capturing a notion that individuals---who make friendships based on
external factors such as office coworkers, familial connections, or neighbourhood proximity---want
their friends to adopt their own beliefs.  Parallels of this in the real world are common in the
political world, where armies of volunteers (who agree strongly with their affiliated party's
political position) attempt to spread their faith in their party to nearby fellow voters.  Another
example is to be found in the devoutly religious, who often receive religious messages as to the
importance of spreading the religious message, e.g.\ spreading ``the word of God.''

Closely related to the model's friendships is a concept of ``voter conviction'', which is a measure
of closeness to the nearest party.  Nearby voters have higher conviction, as they are assumed to
feel more connection with the political system (since there is a party relatively nearby), while
those further away from the nearest party feel more ``left out'' and are thus more apathetic, i.e.\
have lower conviction.  To continue the previous examples, the conviction of a religious
practitioner or political volunteer is thus assumed to be stronger for parishioners or volunteers
closer to that of the religion or party than those whose personal beliefs deviate more strongly.  A
Romney supporter who agrees with all of Romney's policies, for instance, would be expected to be
more passionate in their support of Romney than a voter who votes for Romney only because he is the
marginally closer candidate of two distant options.

Conviction and friendships enter together in how voters influence each other.  At the beginning of
each stage of the model, each voter attempts to influence a random subset of his friends.\footnote{
    The model was also attempted with the alternative formation: each of a random set of voters
    attempts to influence all of his friends.  There was no apparent difference in outcomes between
    the two approaches: each is just a different way of selecting a random set of friendships.
}  If successful, the influenced voter (i.e.\ the friend) changes their position to that of the
influencer; if unsuccessful, the friend doesn't move.  Success is a random outcome, the probability
of which is determined by the convictions of the two voters: voters with high conviction are more
likely to convince friends to move than voters with low conviction; conversely, voters with high
conviction are less likely to be convinced by friend than voters with low conviction.

This procedure alone, however, results in absorbing states: in each iterations of the game, more
populous regions close to an existing party tend to absorb voters from distant regions, who then
strengthen this absorbing effect until voter distribution converges in probability to a single
point.  To counter this problem, the idea of voter ``drift'' was introduced: voters are assumed to have a
natural preference at their initial starting position.  When influenced, a voter jumps to the influencer's
location, but then over time drifts back towards their starting location until they reach it or are
influenced again.

Parties in the model have only limited information on voters, conducted through polling.
The remaining pieces 
An important aspect of voter positions that matters to the model is the concept of voter
``conviction'': voters who are located more closely to the nearest party feel better represented by
the party which, in some sense, validates the voters beliefs.  Voters far away from all parties are
``left out'' and apathetic, i.e. 
that is independent of  Each voter has a fixed set of friends who he
attempts to influence to adopt his own position.   underlying network of friends which
are randomly assigned
(999) of voters and 3 parties The model proceeds in stages involving two types of change: each party of the game Parties can move 


\section{Code}\label{s:code}

\subsection{Eris}\label{s:code:eris}

This project makes extensive use of the open source Eris library, a software library written in the
C++ programming language\footnote{Specifically the C++11 specification of the language.} to serve as
a framework for agent-based modelling in general, with a focus on useful tools for agent-based
computational economics in particular.  The Eris source code is publically available at
\url{https://github.com/erisproject/eris}, and API documentation for the project is publically
available at \url{https://imaginary.ca/eris/api}.

Eris itself is designed for problems that can be divided into sequential iterations supporting multiple
types of interaction between stages.  The simulation itself consists of programming ``objects''
where each object represents an agent, a market, a good, or set of optimization rules.

For example, consider a very simple microeconomic model consisting of a price-setting monopolist and
many (say 100) consumers, with various utility functions.  In the initial setup of the simulation,
the monopolist would start out with an initial price, consumers would start out with an initial
wealth, and a market object would be created with price and output bundles\footnote{There is no
    intrinsic "money" good in Eris, though one created by convention is often useful; a market's
    price can be measured in any arbitrary good, or even in any combination of goods (e.g.\ a bundle
    of 1 left + 1 right shoes).  Thus general equilibrium exchange economies are perfectly
analyzable using Eris, so long as some exchange mechanism is available.}

In each iteration of the simulation consumers are given a simple choice: optimally spend available
wealth on the monopolist's good.  Since the
price is fixed, the decision is a matter of each consumer choosing a utility-maximizing amount.
This requires, however, a Market object in which the consumer can purchase the good from the
monopolist, and a \emph{intra-period optimization} object which attempts to solve the agent's
optimization problem.  There are two of these currently included in Eris: ``MUPD'', which relies on
the consumer having differentiable utility and looks at all available markets and equates the
marginal utility per money unit between all of them; and an ``IncrementalBuyer'' object which
optimizes by subdividing income into many small pieces, spending each increment of income on
whichever yields the largest increased in utility.\footnote{In practice, the MUPD approach works
    much better, but requires that the consumer have a closed-form, differentiable, convex utility
    function.  IncrementalBuyer, on the other hand, is a relatively naïve approach that, while
    putting less requirement on the utility function, often fails to obtain an optimal outcome,
    particularly when there are multiple goods available for purchase and those goods are
    complements or substitutes (since later decisions can potentially affect earlier decisions).
}

The monopolist, on the other hand, needs a way to make pricing decisions.  In a very simple example
included in eris, the monopolist makes use of an \emph{inter-period optimization} object which works
out a price based on stepping the monopolist's price up or down.  Initially, after the first period,
the monopolist has only a single data point consisting of the number of sales of the previous
period, and so can take a step upwards or downwards.  Once the process repeats a second time, the
inter-period optimizer can react by either continuing in the same direction (e.g.\ if the last
price increase resulted in increased profits, perform another increase) or reversing direction
(e.g.\ if the last change was a price increase, but profits went down, reduce price this time).
This optimizer also controls the size of the relative price change, taking larger steps after
multiple steps in the same direction (e.g. multiple increases), or reducing the step size when the
reversing direction.

These pieces work together to achieve the same result as a traditional monopoly model after a few
iterations of the simulation (specifically how many depend on the individual consumer utilities).
Though not particular interesting on its own, the formulation of the problem conveys what makes ACE
an exciting technique: the model structure requires specifying the behaviour of agents and how those
agents interact; it does not impose equilibrium, but rather obtains equilibrium as an
\emph{emergent} property of the simulation.  Furthermore it requires no differentiable demand
function, but instead obtains its outcome through relative simple rules for the agents involved in
the simulation.

Extending the same model to a \emph{quantity}-setting monopolist is also possible, but slightly
harder.  It now requires the creation of a considerably more complicated market structure, as
consumer behaviour is still based on market price.  Thus Eris includes a sort of Walrasian actioneer
(called, rather unimaginatively, a ``QMPricer'' (`Q'uantity `M'arket Pricer) intra-period
optimizer).  This optimization mechanism is capable of performing a few price ``experiments'' in
each round, attempt to determine the price that just barely exhausts the quantity the monopolist has
provided in the market for a given period.  This complexity is, as in the above case, capable of
matching the traditional quantity-setting monopolist outcome after several periods, though it
typically takes longer (both in terms of number iterations and computational complexity) to settle
down, this added time due to the added complexity of the auctioneer experimenting process.

These two examples should, however, be regarded more as benchmarks of the basic building blocks of
the library than useful applications of the library.  While Eris itself provides various useful
functions (the set of which will undoubtedly grow as Eris develops), at its basic level Eris
provides simply a structure in which agents can be easily programmed and given means to interact within and
across time periods.

\subsection{Eris application: Voting model}

In creating the voting model analyzed by this paper, much of the machinery described in the examples
above (markets, goods, and prices) can simply be ignored; they are provided, but not required, for
an Eris-based application.  The first step for the voting model was to create a type of agent that
has a position (of arbitrary dimensions) and bounds on that position.  This was added to Eris itself
(rather than the voting application) as a new type of agent called a ``PositionalAgent''.

The voting application itself includes five classes: two adaptations (or ``subclasses'') of
PositionalAgent (Party and Voter); a Poll agent that can be called upon by other agents to conduct a
poll; a PartyMover inter-period optimizer class moves a given party by a small step based on polling
results; and a Influence inter-period optimizer that influences the ``friends'' of voters.


\section{Future Work}

There is a bevy of changes that could be made to the model quite easily to examine how differences
in the behaviour of model agents affects the outcome.  To summarize just a few:

\begin{itemize}
    \item
        Influence could depend not only on the two agents' conviction levels, but also on the
        distance between the two agents.  This could capture the intuitive notion that it ought to
        be easier for, say, a moderate-left voter located near his party to influence the opinions
        of a far-left voter than to influence the opinion of a far-right voters: in other words,
        it's easier to convince people to take a small move than a big move, given comparable
        conviction levels.
    \item
        The polling/election system here is very simple: voters simply choose the most preferred candidate,
        and there is no distinction between polls and elections.  Changing this would form the most
        immediate next step in enhancing this paper.  This would capture the disconnect that is
        often seen in real-world polling that differs considerably from actual election
        outcomes.\footnote{
            For example, recent provincial elections in British Columbia and Alberta have both badly
            mis-predicted election results well outside the bounds of confidence internals that
            sampling statistics should follow.  \citet{ipsos:prebc}, for instance, reports a
            prediction far from the actual results of the following day's election.
            \citet{ipsos:postbc} attempts to justify the corporation's pre-election polls, but does a poor job of
            it, mostly ignoring the likely fundamental issue that poll respondents are simple not a
        good representative of voters.}  Adding a recurring election stage (e.g.\ every $n$ periods,
        where $n$ is either fixed or a random draw from some distribution) to the computational model developed in this
        paper would be relatively easy: the more complicated part would be in figuring out the
        behaviours that we actually want to capture.  Some interesting poll/election techniques that would be
        worth exploring are:
        \begin{itemize}
            \item
                Polls here are full-population polls (and thus equivalent to an election where everyone
                participates).  Poll sampling (e.g. choosing a small fraction of voters) might be an
                interesting way to introduce a sort of ``realistic noise'' to the process.
            \item
                Voter apathy in the current model is captured (only) in a low conviction value.  It could
                interestingly be incorporated into election outcomes: apathetic voters might still respond
                to polls, but wouldn't turn out to vote.
            \item
                In reality, electoral behaviour is considerably more complicated that voting for the
                nearest party: voters, especially in a first-past-the-post election system often
                vote strategically.  Some proportion of voters (perhaps inversely proportional to
                conviction) could, for example, use the most recent polling information to choose a
                second-best party to prevent the voter's worst choice from winning.  The polling
                mechanism could be updated to match this intended voting or left as is, so that
                polls are only a rough signal of voter intentions.
        \end{itemize}

    \item
        The voter friend network could be made dynamic, so that new friendships form and existing
        friendships fade, with new friendships being more likely among nearby voters, and lost
        friendships being more likely among far off voters.  The model as currently formulated
        assumes that friendships are entirely exogenous, but that assumption seems unrealistic.

\end{itemize}

\section{Conclusion}\label{s:conc}

The Eris framework and voting model developed in this paper offers a compelling direction for
research into voting outcomes.  Unlike traditional models, where modelling decisions are often
influenced by mathematical tractability, ACE models in general---and this voting model in
particular---offer a way to ask questions and explore models that go far beyond the capabilities of
traditional models.  Instead of asking ``can model X be solved for an equilibrium'' we can simply
simulate it and see if an equilibrium emerges.  Our modelling requirements become fundamentally
different: rather than calculating optimal behaviour

This is, however, only a complement rather than a substitute for a proof-based approach: we could
turn up wrong answers, could randomly get spurious outcomes that look like equilibria but aren't, or
could fail to find some or all equilibria.  These are, as \citet{hce:Judd} and \citet{Tukey62} point
out, not failures of a 


%implementation.
%framework how the library worksmore It should be point
%Optimization objet Eris provides a couple of
%built-in object classes to do this optimization: one which depends on the consumers having
%differentiable utility, which There n optimal have a choice: Consumers would respond to that price
%in making a purchasing decision based on the price and their own rules.  For the next period, the
%monopolist now has the number of sales in the previous period, and can adjust the next period's
%price upward or downward.  After this process repeats again, the monopolist has additional
%information on demand and can use the previous two steps to determine whether to take another price
%change in the same direction, or whether to reverse direction.  This inter-period pricing decision
%is known in Eris teminology as an \emph{inter-period optimization}, the logic for which is contained
%in a dedicated object.
%
%step in th
%downwardFor example, one set of consumer
%behaviour .  Depending on the quantity sold in the period, the
%monopolist could 
%
%The Eris library itself makes extensive use of object-oriented programming, whereby each component
%of a simulation is in an independent ``object'' that has various methods or functions that are
%called to interact with the object.  Eris models are designed to handle sequential time problems,
%where the sequences can b be
%some of the simple
%examples included with Eris, and interlibrary mplements, at its core, a simulation, which itself includes multiple agents, markets,
%goods, intra-period optimizers, and inter-period optimizers.
%


\end{document}
